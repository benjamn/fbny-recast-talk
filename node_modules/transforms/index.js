var recast = require("recast");
var types = recast.types;
var n = types.namedTypes;
var b = types.builders;
var isString = types.builtInTypes.string;

exports.transformArrowFunctions = function(source) {
  var ast = recast.parse(source);

  recast.visit(ast, {
    visitArrowFunctionExpression: function(path) {
      var node = path.node;

      if (n.Function.check(node) && node.expression) {
        node.expression = false;
        node.body = b.blockStatement([b.returnStatement(node.body)]);
      }

      if (n.ArrowFunctionExpression.check(node)) {
        var funExp = b.functionExpression(
          node.id, node.params, node.body,
          node.generator, node.expression
        );

        return b.callExpression(
          b.memberExpression(funExp, b.identifier("bind"), false),
          [b.thisExpression()]
        );
      }
    }
  });

  return recast.print(ast).code;
};

exports.transformEvents = function(source) {
  var ast = recast.parse(source);
  recast.visit(ast, eventsVisitor);
  return recast.print(ast).code;
};

var eventsVisitor = types.PathVisitor.fromMethodsObject({
  visitObjectExpression: function(objPath) {
    this.traverse(objPath);

    if (!isExtendMethodCall(objPath.parent.node)) {
      return;
    }

    var eventsObjectPath;
    var eventsObjectProperties = [];

    objPath.get("properties").each(function(propPath) {
      var keyPath = propPath.get("key");
      var keyName = keyPath.node.name;
      var valuePath = propPath.get("value");

      if (!n.Identifier.check(keyPath.node)) {
        return;
      }

      if (keyName === "events") {
        n.ObjectExpression.assert(valuePath.node);
        eventsObjectPath = valuePath;
        return;
      }

      if (keyName === "onLoad") {
        var funcPath = propPath.get("value");
        if (!n.FunctionExpression.check(funcPath.node)) {
          return;
        }

        funcPath.get("body", "body").each(function(stmtPath) {
          var call = getJQueryBindingCallExpr(stmtPath.node);
          if (call) {
            var firstArg = call.arguments[0];
            var eventName = call.callee.property.name;
            var selector = call.callee.object.arguments[0];

            if (eventName === "bind") {
              n.Literal.assert(firstArg);
              eventName = firstArg.value;
              firstArg = call.arguments[1];
            }

            isString.assert(eventName);
            n.Literal.assert(selector);
            isString.assert(selector.value);

            eventsObjectProperties.push(b.property(
              "init",
              b.literal(eventName + " " + selector.value),
              getUnboundCallback(firstArg)
            ));

            stmtPath.prune();
          }
        });
      }
    });

    if (eventsObjectPath) {
      var existingEventProperties = eventsObjectPath.get("properties");
      existingEventProperties.push.apply(
        existingEventProperties,
        eventsObjectProperties
      );
    } else {
      objPath.get("properties").push(
        b.property(
          "init",
          b.identifier("events"),
          b.objectExpression(eventsObjectProperties)
        )
      );
    }
  }
});

function isExtendMethodCall(node) {
  return n.CallExpression.check(node)
    && n.MemberExpression.check(node.callee)
    && n.Identifier.check(node.callee.property)
    && node.callee.property.name === "extend";
}

function getJQueryBindingCallExpr(node) {
  var expr;
  if (n.ExpressionStatement.check(node)) {
    expr = node.expression;
  } else if (n.Expression.check(node)) {
    expr = node;
  } else {
    return false;
  }

  return n.CallExpression.check(expr)
    && n.MemberExpression.check(expr.callee)
    && n.CallExpression.check(expr.callee.object)
    && n.MemberExpression.check(expr.callee.object.callee)
    && n.ThisExpression.check(expr.callee.object.callee.object)
    && n.Identifier.check(expr.callee.object.callee.property)
    && expr.callee.object.callee.property.name === "$"
    && expr;
}

function getUnboundCallback(node) {
  var callback = node;

  if (isBindCall(callback)) {
    callback = callback.arguments[0];
  }

  n.FunctionExpression.assert(callback);

  return callback;
}

function isBindCall(node) {
  return n.CallExpression.check(node)
    && n.MemberExpression.check(node.callee)
    && n.ThisExpression.check(node.callee.object)
    && n.Identifier.check(node.callee.property)
    && node.callee.property.name === "bind";
}
